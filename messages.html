

<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>ChatSpace â€” Messages</title>
<style>
  :root{
    --bg:#f6f7fb; --card:#fff; --border:#e6e8ef; --text:#0f172a; --muted:#64748b;
    --accent:#3b82f6; --danger:#ef4444; --bubble:#fff; --me:#eef2ff; --link:#2563eb
  }
  :root[data-theme="dark"]{
    --bg:#0b1220; --card:#0f172a; --border:#1f2a44; --text:#e5e7eb; --muted:#93a4c7;
    --accent:#60a5fa; --danger:#f87171; --bubble:#111827; --me:#1e293b; --link:#93c5fd
  }
  *{box-sizing:border-box} body{margin:0;font-family:system-ui,Segoe UI,Arial;color:var(--text);background:var(--bg)}
  a{color:var(--link)}
  header{position:sticky;top:0;z-index:5;background:var(--card);border-bottom:1px solid var(--border);padding:10px 12px}
  .bar{display:flex;flex-wrap:wrap;gap:8px;align-items:center;justify-content:space-between}
  .left,.right{display:flex;gap:8px;align-items:center}
  .btn{padding:8px 12px;border:1px solid var(--border);border-radius:999px;background:transparent;color:var(--text);cursor:pointer}
  .btn.primary{background:var(--accent);border-color:var(--accent);color:#fff}
  .btn.danger{background:#fee2e2;border-color:#fecaca;color:#991b1b}
  .wrap{max-width:1100px;margin:0 auto;padding:12px}
  .row{display:flex;gap:8px;align-items:center}
  .col{display:flex;flex-direction:column;gap:10px}
  .card{background:var(--card);border:1px solid var(--border);border-radius:14px;padding:12px}
  .grid{display:grid;grid-template-columns:320px 1fr;gap:12px}
  @media(max-width:900px){.grid{grid-template-columns:1fr}}
  .input, textarea{width:100%;padding:10px;border:1px solid var(--border);border-radius:10px;background:transparent;color:var(--text)}
  .list>*+*{border-top:1px solid var(--border);margin-top:8px;padding-top:8px}
  #chat{display:flex;flex-direction:column;gap:8px;max-height:60vh;overflow:auto;scroll-behavior:smooth}
  .bubble{border:1px solid var(--border);background:var(--bubble);border-radius:12px;padding:10px;position:relative}
  .me{background:var(--me)}
  .muted{color:var(--muted)} .mono{font-family:ui-monospace,Menlo,Consolas,monospace;font-size:12px}
  .userItem{display:flex;justify-content:space-between;align-items:center;padding:8px;border:1px solid var(--border);border-radius:10px}
  img.msg{max-width:260px;border-radius:10px;display:block;margin-top:6px}
  .tiny{font-size:12px;color:var(--muted)}
  .pill{padding:2px 6px;border-radius:6px;border:1px solid var(--border);margin-left:6px}
  .actions{display:flex;gap:6px;margin-top:6px}
  .reacts{display:flex;gap:6px;flex-wrap:wrap;margin-top:6px}
  .chip{border:1px solid var(--border);border-radius:999px;padding:2px 8px;font-size:12px}
  .reply{border-left:3px solid var(--border);padding-left:8px;margin:6px 0 4px;color:var(--muted);font-size:13px}
  .preview{opacity:.9}
  .inline{display:inline-flex;gap:6px;align-items:center}
  .avatar{width:28px;height:28px;border-radius:50%;object-fit:cover;border:1px solid var(--border)}
</style>
</head>
<body>
<header>
  <div class="bar">
    <div class="left">
      <strong>ChatSpace</strong>
      <a class="btn" href="./messages.html">ğŸ’¬ Messages</a>
      <a class="btn" href="./groups.html">ğŸ‘¥ Groups</a>
    </div>
    <div class="right">
      <button id="themeBtn" class="btn">ğŸŒ“ Theme: <span id="themeName">Light</span></button>
      <button id="soundBtn" class="btn">ğŸ”Š <span id="soundState">On</span></button>
      <button id="notifBtn" class="btn">ğŸ”” Notifications</button>
      <button id="testNotif" class="btn">âœ… Test</button>
    </div>
  </div>
</header>

<div class="wrap col">
  <div id="status" class="tiny"></div>

  <!-- identity + profile -->
  <div class="card col">
    <div class="row">
      <input id="me" class="input" placeholder="username (e.g. alice)"/>
      <button id="claim" class="btn primary">Use</button>
      <span id="adminBadge" class="tiny pill"></span>
      <span class="tiny">Share: <span id="share" class="mono"></span></span>
    </div>
    <div class="row">
      <input id="dispName" class="input" placeholder="display name (optional)"/>
      <input id="avatarFile" type="file" accept="image/*"/>
      <button id="saveProfile" class="btn">Save profile</button>
      <span class="tiny">Profile is shown in chat bubbles.</span>
    </div>
  </div>

  <div class="grid">
    <!-- left -->
    <div class="col">
      <div class="card">
        <div class="row">
          <input id="findUser" class="input" placeholder="find usernameâ€¦"/>
          <button id="sendReq" class="btn">Add Friend</button>
        </div>
      </div>

      <div class="card">
        <h3 style="margin:0 0 6px">Incoming</h3>
        <div id="incoming" class="list tiny"></div>
      </div>

      <div class="card">
        <h3 style="margin:0 0 6px">Friends</h3>
        <div id="friends" class="list tiny"></div>
      </div>

      <div class="card">
        <h3 style="margin:0 6px 6px 0" class="inline">
          Messages Search
          <input id="searchBox" class="input" placeholder="filter current chatâ€¦" style="max-width:180px"/>
        </h3>
        <div class="tiny">Search is local to the open conversation.</div>
      </div>

      <div class="card">
        <h3 style="margin:0 0 6px">Registered Users</h3>
        <div id="registered" class="col"></div>
        <div class="tiny">As <b>tosh1</b> you can delete users.</div>
      </div>
    </div>

    <!-- right: chat -->
    <div class="col">
      <div class="card col">
        <div class="row" style="justify-content:space-between">
          <div class="inline">
            <img id="peerAvatar" class="avatar" alt="">
            <div>Chatting with <span id="peer" class="mono">â€”</span>
              <span id="peerDisp" class="pill tiny"></span>
            </div>
          </div>
          <div id="typing" class="tiny muted"></div>
        </div>

        <div id="chat"></div>

        <!-- reply preview -->
        <div id="replyBar" class="reply" style="display:none">
          Replying to <span id="replyMeta"></span>
          <button id="cancelReply" class="btn tiny" style="margin-left:8px">âœ•</button>
        </div>

        <!-- image PREVIEW bubble (local only) -->
        <div id="previewWrap" class="bubble preview" style="display:none">
          <div class="muted mono">Preview (not sent)</div>
          <img id="previewImg" class="msg" alt="preview">
        </div>

        <!-- composer -->
        <div class="row"><textarea id="msg" placeholder="Type a messageâ€¦ (Enter to send)"></textarea></div>
        <div class="row" style="justify-content:space-between">
          <input id="file" type="file" accept="image/*"/>
          <div class="row">
            <button id="send" class="btn primary">Send</button>
            <button id="clearFile" class="btn">Clear preview</button>
          </div>
        </div>
        <div id="seenBar" class="tiny muted"></div>
      </div>
    </div>
  </div>
</div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.13.1/firebase-app.js";
import { getDatabase, ref, onValue, off, set, update, push, get, child, onDisconnect, serverTimestamp, remove } from "https://www.gstatic.com/firebasejs/10.13.1/firebase-database.js";
import { getStorage, ref as sref, uploadBytes, getDownloadURL } from "https://www.gstatic.com/firebasejs/10.13.1/firebase-storage.js";

const app = initializeApp({ databaseURL: "https://my-chat-ddcd1-default-rtdb.firebaseio.com/" });
const db = getDatabase(app);
const storage = getStorage(app);

// ===== Theme / Sound / Notifications =====
const root=document.documentElement, themeBtn=$('#themeBtn'), themeName=$('#themeName');
applyTheme(localStorage.getItem('cs_theme')||'light');
function applyTheme(th){ root.setAttribute('data-theme', th==='dark'?'dark':'light'); themeName.textContent=th==='dark'?'Dark':'Light'; localStorage.setItem('cs_theme', th); }
themeBtn.onclick=()=>applyTheme(root.getAttribute('data-theme')==='dark'?'light':'dark');

let soundOn=(localStorage.getItem("cs_sound")||"on")==="on";
$('#soundState').textContent = soundOn?"On":"Off";
$('#soundBtn').onclick=()=>{ soundOn=!soundOn; localStorage.setItem("cs_sound",soundOn?"on":"off"); $('#soundState').textContent=soundOn?"On":"Off"; if(soundOn){ ensureAudio(); ding(); } };
let audioCtx=null; function ensureAudio(){ if(!audioCtx){ try{ audioCtx=new (window.AudioContext||window.webkitAudioContext)(); }catch{} } if(audioCtx&&audioCtx.state==="suspended"){ audioCtx.resume(); } }
function ding(){ if(!soundOn) return; ensureAudio(); if(!audioCtx) return; const c=audioCtx; let s=c.currentTime; [[660,0.18],[990,0.28]].forEach(([f,d])=>{ const o=c.createOscillator(), g=c.createGain(); o.type="square"; o.frequency.setValueAtTime(f,s); g.gain.setValueAtTime(0.0001,s); g.gain.exponentialRampToValueAtTime(0.22,s+0.02); g.gain.exponentialRampToValueAtTime(0.0001,s+d); o.connect(g).connect(c.destination); o.start(s); o.stop(s+d+0.01); s+=d+0.02;}); }
window.addEventListener("click", ensureAudio, { once:true });

$('#notifBtn').onclick = async ()=>{ if(!("Notification" in window)) return alert("No Notifications support"); const p=await Notification.requestPermission(); if(p!=="granted") alert("Allow notifications"); else new Notification("Notifications enabled ğŸ‰"); };
$('#testNotif').onclick = ()=>{ if("Notification" in window && Notification.permission==="granted"){ new Notification("Test notification",{body:"DM notifications working"}); } else alert("Enable notifications first."); };

// ===== helpers =====
const $=s=>document.querySelector(s), t=()=>Date.now(), tid=(a,b)=>[a,b].sort().join("__");
const esc=s=>(s||"").replace(/[<>&]/g,m=>({ '<':'&lt;','>':'&gt;','&':'&amp;' }[m]));
function info(m){ const el=$("#status"); el.textContent=m; setTimeout(()=>el.textContent="",2400); }
function fmtTime(ts){ const d=new Date(ts||Date.now()); return d.toLocaleTimeString(); }

// els
const meBox=$("#me"), claim=$("#claim"), share=$("#share"), adminBadge=$("#adminBadge");
const dispName=$("#dispName"), avatarFile=$("#avatarFile"), saveProfile=$("#saveProfile");
const incoming=$("#incoming"), friends=$("#friends"), registered=$("#registered");
const peerEl=$("#peer"), peerDisp=$("#peerDisp"), peerAvatar=$("#peerAvatar");
const chat=$("#chat"), msg=$("#msg"), send=$("#send");
const file=$("#file"), clearFile=$("#clearFile"), previewWrap=$("#previewWrap"), previewImg=$("#previewImg");
const findUser=$("#findUser"), sendReq=$("#sendReq"), searchBox=$("#searchBox");
const typingEl=$("#typing"), replyBar=$("#replyBar"), replyMeta=$("#replyMeta"), cancelReply=$("#cancelReply"), seenBar=$("#seenBar");

let me=null, admin=false, currentPeer=null, dmRef=null, dmCb=null, reactionsRef=null, reactionsCb=null;
let profilesCache = {}; // username -> {displayName, avatarUrl}
let replyTo = null;     // {id, from, text}
let currentMessages = []; // cache for search
let peerReadTs = 0;

// presence
async function presence(){
  if(!me) return;
  const p=ref(db,'presence/'+me);
  await set(p,{online:true,lastSeen: serverTimestamp()});
  onDisconnect(p).set({online:false,lastSeen: serverTimestamp()});
  setInterval(()=>update(p,{online:true,lastSeen:serverTimestamp()}),30000);
}

// profiles
async function loadProfile(u){
  if(profilesCache[u]) return profilesCache[u];
  const s = await get(child(ref(db),'profiles/'+u));
  profilesCache[u] = s.val() || {};
  return profilesCache[u];
}
async function saveMyProfile(){
  const dn = (dispName.value||'').trim();
  let avatarUrl = profilesCache[me]?.avatarUrl || null;
  if(avatarFile.files && avatarFile.files[0]){
    const f=avatarFile.files[0]; const path=`avatars/${me}_${Date.now()}_${f.name.replace(/\s+/g,'_')}`;
    const upRef=sref(storage, path); await uploadBytes(upRef,f); avatarUrl = await getDownloadURL(upRef);
  }
  await set(ref(db,'profiles/'+me), { displayName: dn || null, avatarUrl: avatarUrl || null, updatedAt:t() });
  profilesCache[me] = { displayName: dn || null, avatarUrl: avatarUrl || null };
  info('Profile saved');
}
saveProfile.onclick=saveMyProfile;

// identity
async function use(){
  const u=(meBox.value||'').trim().toLowerCase(); if(!u) return;
  const s=await get(child(ref(db),'users/'+u)); if(!s.exists()) await set(ref(db,'users/'+u),{createdAt:t()});
  me=u; admin=(me==='tosh1'); localStorage.setItem("cs_username",me);
  history.replaceState({},'',location.pathname+'?u='+me);
  share.textContent=location.origin+location.pathname+'?u='+me;
  adminBadge.textContent = admin ? 'Admin: tosh1' : '';
  await loadProfile(me);
  info('Using @'+me+(admin?' (admin)':''));
  presence(); lists(); watchUsers();
}
claim.onclick=use;
const saved=(localStorage.getItem("cs_username")||"").trim(); if(saved){ meBox.value=saved; use(); }

// lists (requests/friends)
function lists(){
  if(!me) return;
  let prev=0;
  onValue(ref(db,'requests/'+me),(snap)=>{
    const d=snap.val()||{};
    const inc=Object.entries(d).filter(([,r])=>r.status==='pending').map(([from,r])=>({from,ts:r.ts})).sort((a,b)=>b.ts-a.ts);
    if(inc.length>prev){ ding(); if("Notification" in window && Notification.permission==="granted"){ new Notification('New friend request',{body:'@'+inc[0].from}); } }
    prev=inc.length;
    incoming.innerHTML = inc.length ? inc.map(r=>`
      <div class="row">
        <span>@${esc(r.from)}</span>
        <button class="btn primary" data-accept="${esc(r.from)}">Accept</button>
        <button class="btn" data-decline="${esc(r.from)}">Decline</button>
      </div>`).join('') : '<span class="muted">None</span>';
  });
  onValue(ref(db,'friendships/'+me),(snap)=>{
    const f=snap.val()||{}; const arr=Object.keys(f).sort();
    friends.innerHTML = arr.length ? arr.map(u=>`
      <div class="row">
        <span>@${esc(u)}</span>
        <button class="btn primary" data-open="${esc(u)}">Open</button>
      </div>`).join('') : '<span class="muted">No friends yet</span>';
  });
}

// users list
function watchUsers(){
  onValue(ref(db,'users'), async (su)=>{
    const users=su.val()||{};
    const names = Object.keys(users).sort();
    // preload minimal profiles
    await Promise.all(names.map(n=>loadProfile(n)));
    registered.innerHTML = names.map(u=>{
      const p=profilesCache[u]||{};
      const tag = p.displayName ? ` â€” ${esc(p.displayName)}` : '';
      return `<div class="userItem">
        <span>@${esc(u)}<span class="tiny">${tag}</span></span>
        <div class="row">
          <button class="btn" data-add="${esc(u)}">Add</button>
          ${admin && u!=='tosh1' ? `<button class="btn danger" data-deluser="${esc(u)}">Delete</button>`:''}
        </div>
      </div>`;
    }).join('');
  });
}

// typing indicator
let typingTimer=null;
function setTyping(is){
  if(!currentPeer) return;
  set(ref(db,'typing/'+tid(me,currentPeer)+'/'+me), !!is);
  if(is){
    clearTimeout(typingTimer);
    typingTimer=setTimeout(()=>set(ref(db,'typing/'+tid(me,currentPeer)+'/'+me), false), 2500);
  }
}
msg.addEventListener('input',()=>setTyping(true));

// reply bar
function setReply(m){
  replyTo = m ? { id:m.id, from:m.from, text:(m.text||'') } : null;
  if(replyTo){
    replyMeta.textContent = `@${replyTo.from}: ${replyTo.text.slice(0,80)}`;
    replyBar.style.display = 'block';
  }else{
    replyBar.style.display = 'none';
  }
}
cancelReply.onclick=()=>setReply(null);

// local IMAGE PREVIEW
file.addEventListener('change', ()=>{
  if(file.files && file.files[0]){
    const url = URL.createObjectURL(file.files[0]);
    previewImg.src = url;
    previewWrap.style.display = 'block';
  } else { previewWrap.style.display='none'; previewImg.removeAttribute('src'); }
});
clearFile.onclick=()=>{ file.value=''; previewWrap.style.display='none'; previewImg.removeAttribute('src'); };

// render helpers
function profileTag(u){
  const p=profilesCache[u]||{};
  return p.displayName ? ` <span class="tiny pill">${esc(p.displayName)}</span>` : '';
}
function avatarUrlOf(u){ return (profilesCache[u] && profilesCache[u].avatarUrl) || ''; }

function render(arr, reactions){
  currentMessages = arr;
  const filt = (searchBox.value||'').toLowerCase();
  const peerSeenTs = peerReadTs || 0;

  chat.innerHTML = arr
    .filter(m=>{
      if(!filt) return true;
      const hay = (m.text||'') + ' ' + (m.replyTo?.text||'');
      return hay.toLowerCase().includes(filt);
    })
    .map(m=>{
      const owns = m.from===me; const canDel = owns || admin;
      const rs = reactions[m.id]||{};
      const tally = (emoji)=> Object.keys(rs[emoji]||{}).length;
      const youReacted = (emoji)=> !!(rs[emoji] && rs[emoji][me]);

      const replyHtml = m.replyTo ? `<div class="reply tiny">@${esc(m.replyTo.from)}: ${esc(m.replyTo.text||'')}</div>` : '';
      const seenMark = (!owns || !m.ts) ? '' : (peerSeenTs>=m.ts ? `<span class="tiny muted">Seen</span>`:'');
      const edited = m.edited ? `<span class="tiny muted"> (edited)</span>` : '';

      const av = avatarUrlOf(m.from);
      return `<div class="bubble ${owns?'me':''}" data-id="${esc(m.id)}">
        <div class="inline">
          ${av ? `<img class="avatar" src="${esc(av)}" alt="">` : `<span class="avatar" style="background:#ddd"></span>`}
          <div class="muted mono">@${esc(m.from)}</div>${profileTag(m.from)} <span class="tiny muted">â€¢ ${fmtTime(m.ts)}</span>
        </div>
        ${replyHtml}
        ${m.text?`<div>${esc(m.text)}${edited}</div>`:''}
        ${m.imageUrl?`<img class="msg" src="${esc(m.imageUrl)}" alt="image">`:''}

        <div class="actions">
          <button class="btn tiny" data-reply="${esc(m.id)}">â†© Reply</button>
          <button class="btn tiny" data-react="${esc(m.id)}" data-emoji="ğŸ‘">${youReacted('ğŸ‘')?'âœ…':''} ğŸ‘ ${tally('ğŸ‘')||''}</button>
          <button class="btn tiny" data-react="${esc(m.id)}" data-emoji="â¤ï¸">${youReacted('â¤ï¸')?'âœ…':''} â¤ï¸ ${tally('â¤ï¸')||''}</button>
          <button class="btn tiny" data-react="${esc(m.id)}" data-emoji="ğŸ˜‚">${youReacted('ğŸ˜‚')?'âœ…':''} ğŸ˜‚ ${tally('ğŸ˜‚')||''}</button>
          ${owns?`<button class="btn tiny" data-edit="${esc(m.id)}">âœ Edit</button>`:''}
          ${canDel?`<button class="btn tiny" data-del="${esc(m.id)}">ğŸ—‘</button>`:''}
          <span style="flex:1"></span>${seenMark}
        </div>
      </div>`;
    }).join('');
  chat.scrollTop = chat.scrollHeight;
}

// open DM
let typingUnsub=null, readsUnsub=null, reactionsUnsub=null;
async function openDM(peer){
  currentPeer=peer; peerEl.textContent='@'+peer; chat.innerHTML='';
  const pp = await loadProfile(peer); peerDisp.textContent = pp.displayName? 'â€¢ '+pp.displayName : ''; peerAvatar.src = pp.avatarUrl||'';
  if(dmRef&&dmCb) off(dmRef, dmCb); if(typingUnsub) off(typingUnsub.ref, typingUnsub.cb); if(readsUnsub) off(readsUnsub.ref, readsUnsub.cb); if(reactionsUnsub) off(reactionsUnsub.ref, reactionsUnsub.cb);

  // messages
  dmRef = ref(db,'messages/'+tid(me,peer));
  let last=0;
  dmCb = (snap)=>{
    const d=snap.val()||{}; const arr=Object.entries(d).map(([id,m])=>({id,...m})).sort((a,b)=>a.ts-b.ts);
    if(arr.length>last){
      const L=arr[arr.length-1]; if(L && L.from!==me){ ding(); if("Notification" in window && Notification.permission==="granted"){ new Notification("New message from @"+L.from,{body:L.text||'Photo'}); } }
    }
    last=arr.length;
    // update my read receipt to last message ts
    const lastTs = arr.length? arr[arr.length-1].ts : 0;
    if(lastTs) set(ref(db,'reads/'+tid(me,peer)+'/'+me), lastTs);
    render(arr, cachedReactions);
  };
  onValue(dmRef, dmCb);

  // typing watcher (peer typing)
  const typRef = ref(db,'typing/'+tid(me,peer)+'/'+peer);
  const typCb = s=> typingEl.textContent = s.val()? `@${peer} is typingâ€¦` : '';
  onValue(typRef, typCb); typingUnsub={ref:typRef, cb:typCb};

  // peer read receipts
  const rdRef = ref(db,'reads/'+tid(me,peer)+'/'+peer);
  const rdCb = s=>{ peerReadTs = s.val()||0; render(currentMessages, cachedReactions); };
  onValue(rdRef, rdCb); readsUnsub={ref:rdRef, cb:rdCb};

  // reactions cache
  const reactRef = ref(db,'reactions/'+tid(me,peer));
  const rCb = s=>{ cachedReactions = s.val()||{}; render(currentMessages, cachedReactions); };
  onValue(reactRef, rCb); reactionsUnsub={ref:reactRef, cb:rCb};
}
let cachedReactions = {};

// send
async function sendMsg(){
  if(!currentPeer) return;
  const text=(msg.value||'').trim();
  let imageUrl=null;
  if(file.files && file.files[0]){
    const f=file.files[0];
    const path=`uploads/${me}/${Date.now()}_${f.name.replace(/\s+/g,'_')}`;
    const upRef=sref(storage, path);
    await uploadBytes(upRef, f);
    imageUrl = await getDownloadURL(upRef);
  }
  if(!text && !imageUrl && !replyTo) return;
  await push(ref(db,'messages/'+tid(me,currentPeer)), { from: me, to: currentPeer, text, imageUrl, ts:t(), ...(replyTo?{replyTo}:{}) });
  msg.value=''; if(imageUrl){ file.value=''; previewWrap.style.display='none'; previewImg.removeAttribute('src'); }
  setReply(null);
  setTyping(false);
}
send.onclick=sendMsg;
msg.addEventListener('keydown',e=>{ if(e.key==='Enter'&&!e.shiftKey){ e.preventDefault(); sendMsg(); } });

// search
searchBox.addEventListener('input', ()=>render(currentMessages, cachedReactions));

// actions (friend reqs, open, react, edit, delete, reply)
async function addFriend(u){
  if(!me) return;
  const s=await get(child(ref(db),'users/'+u)); if(!s.exists()) return alert('User not found');
  await set(ref(db,'requests/'+u+'/'+me), { status:'pending', ts:t() }); info('Request sent.');
}
async function accept(u){
  await update(ref(db),{
    ['requests/'+me+'/'+u+'/status']:'accepted',
    ['friendships/'+me+'/'+u]:true,['friendships/'+u+'/'+me]:true
  }); info('Accepted.');
}
async function decline(u){ await update(ref(db),{['requests/'+me+'/'+u+'/status']:'declined'}); info('Declined.'); }
async function delMsg(id){ if(!currentPeer) return; await remove(ref(db,'messages/'+tid(me,currentPeer)+'/'+id)); }
async function reactMsg(id, emoji){
  const path='reactions/'+tid(me,currentPeer)+'/'+id+'/'+emoji+'/'+me;
  const cur=await get(child(ref(db), path));
  await set(ref(db, path), cur.exists()? null : true);
}
async function editMsg(id){
  const node = await get(child(ref(db),'messages/'+tid(me,currentPeer)+'/'+id));
  const m=node.val(); if(!m || m.from!==me) return;
  const text = prompt("Edit message:", m.text||""); if(text===null) return;
  await update(ref(db,'messages/'+tid(me,currentPeer)+'/'+id), { text, edited:true });
}
document.body.addEventListener('click',(e)=>{
  const o=e.target.getAttribute('data-open'); if(o){ openDM(o); return; }
  const a=e.target.getAttribute('data-accept'); if(a){ accept(a); return; }
  const d=e.target.getAttribute('data-decline'); if(d){ decline(d); return; }
  const add=e.target.getAttribute('data-add'); if(add){ addFriend(add); return; }
  const del=e.target.getAttribute('data-del'); if(del){ delMsg(del); return; }
  const ed=e.target.getAttribute('data-edit'); if(ed){ editMsg(ed); return; }
  const rp=e.target.getAttribute('data-reply'); if(rp){ const m=currentMessages.find(x=>x.id===rp); if(m) setReply(m); return; }
  const rx=e.target.getAttribute('data-react'); if(rx){ const em=e.target.getAttribute('data-emoji'); reactMsg(rx, em); return; }
});
sendReq.onclick=async()=>{ const u=(findUser.value||'').trim().toLowerCase(); if(u) addFriend(u); };
</script>
</body>
</html>

